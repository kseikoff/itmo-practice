\documentclass[a4paper,14pt]{extarticle}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel}

\usepackage[left=30mm, right=10mm, top=20mm, bottom=20mm]{geometry}

\usepackage{tempora}
\usepackage{setspace}
\onehalfspacing

\usepackage{titlesec}
\titleformat{\section}[block]{\bfseries\centering\MakeUppercase}{\thesection.}{1em}{}
\titleformat{\subsection}[block]{\bfseries}{\thesubsection.}{1em}{}
\titleformat{\subsubsection}[block]{\normalsize\bfseries}{\thesubsubsection.}{1em}{}

\renewcommand{\contentsname}{\hfill \textbf{СОДЕРЖАНИЕ} \hfill\null}

\usepackage{indentfirst}
\setlength{\parindent}{1.25cm}

\usepackage{amsmath, amsfonts, amssymb}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage{tikz}
\usetikzlibrary{patterns}
\usepackage{cmap}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{paralist}

\definecolor{LightGray}{gray}{0.7}

\lstdefinestyle{code}{
    language=Python,
    basicstyle=\small\ttfamily,
    numbers=left,
    numberstyle=\small\color{LightGray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=4,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    frame=single,
    rulecolor=\color{LightGray},
    linewidth=\linewidth,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!40!black},
    stringstyle=\color{violet},
    escapeinside={\%*}{*)},
    xleftmargin=10pt,
    xrightmargin=10pt,
    framexleftmargin=0pt,
    framexrightmargin=0pt
}
\lstset{style=code}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    pdftitle={ITMO Practice},
    pdfauthor={Rumyantsev Alexey},
    pdfsubject={TCP computer-robot communication},
    pdfkeywords={LaTeX, PDF, robot, tcp},
    pdfpagemode=FullScreen,
}

\graphicspath{{src/images/}}

\begin{document}

\begin{titlepage}
    \begin{center}
        \textbf{Федеральное государственное автономное образовательное учреждение высшего образования}\\
        \textbf{«НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ ИТМО»}\medskip\\
        \textbf{Факультет систем управления и робототехники}
        \vfill

        {\large\bfseries Отчет о}\\
        {\large\bfseries научно исследовательской работе}\medskip\\
        {\large\bfseries по теме:}\\
        {\large\bfseries «РАЗРАБОТКА АЛГОРИТМОВ ДЛЯ ВЗАИМОДЕЙСТВИЯ С РОБОТОМ-МАНИПУЛЯТОРОМ С КОМПЬЮТЕРА (С ИСПОЛЬЗОВАНИЕМ TCP)»}
        \vfill

        \begin{flushright}
            Выполнил: студент гр. R3341\\
            А. А. Румянцев\medskip\\

            Проверил: преподаватель\\
            доцент, старший научный сотрудник, инженер В. С. Громов
        \end{flushright}

        \vfill

        Санкт-Петербург\\
        2025 г.
    \end{center}
\end{titlepage}

\setcounter{page}{2}
\tableofcontents
\newpage


\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\setcounter{section}{0}
В настоящее время в промышленной и других сферах все чаще
используются роботы-манипуляторы, управляемые
со специального пульта или автоматически
через загрузку программы на робота.
Более предпочтительным является вариант
управления без человека -- это безопаснее
и выгоднее. Однако роботы используют
достаточно устаревший язык программирования,
например MELFA-BASIC. Написание кода
для подобных роботов может быть неудобным,
а программы получаться громоздкими.
Разработка нового языка программирования
для роботов потребует больших вложений,
что также не выгодно. Управление с пульта,
в свою очередь,
требует от оператора высокой квалификации --
необходимы знания техники безопасности и
принципы работы оборудования. Обучение
специалиста для управления роботом-манипулятором с пульта
является ресурсоемким процессом, требующим
значительных временных и финансовых затрат.


Для повышения безопасности и эффективности
взаимодействия с роботом,
необходимо максимально отдалить человека
от робота, при этом реализовать все основные
функции для работы с ним так, чтобы их можно
было использовать из некой виртуальной централизованной
системы по нажатию кнопок. Реализовать данную идею
можно в виде программного интерфейса -- аналога физического
пульта управления роботом в
виде программы на компьютере.
Такой подход также
позволит упростить обучение специалистов для управления
роботом-манипулятором. Кроме того, программу можно
купить один раз и установить на множество компьютеров,
а разработка и покупка нескольких физических пультов управления
будет ресурсозатратным процессом.
Однако сейчас программных интерфейсов, позволяющих взаимодействовать
с роботом с компьютера сравнительно немного,
а те, что уже есть, постепенно устаревают.
Возникает необходимость написания нового
программного интерфейса для взаимодействия с роботом.
Как и любая другая программа, структурно она делится на две
части -- одна отвечает за внешний вид
и удобство управления (сам интерфейс),
другая же обеспечивает взаимодействие с роботом
на уровне, не видном пользователю.
В рамках данной работы разрабатывалась
внутрення логика программы для
взаимодействия компьютера с
роботом-манипулятором по протоколу TCP.
Пользовательская часть интерфейса при этом рассматривалась как вспомогательная.


\section{Подготовка к написанию программы}
\subsection{Ознакомление с объектом работы}
Перед выполнением задания был проведен
инструктаж по технике безопасности обращения
с роботом-манипулятором. Под наблюдением преподавателя
были изучены ручной режим
управления роботом со специального пульта и
автоматический с помощью простейших программ
на языке MELFA-BASIC, загружаемых на робота.


Для написания программ для робота был изучен язык программирования
MELFA-BASIC, некоторые его основные команды и описание представлены
далее:
\begin{compactitem}
    \item \textbf{SERVO ON} -- включение двигателей,
    \item \textbf{SERVO OFF} -- выключение двигателей,
    \item \textbf{END} -- завершение программы, обязательно размещается в конце файла,
    \item \textbf{JOVRD 100} -- скорость движения в процентах от максимальной,
    \item \textbf{SPD 100} -- скорость движения при интерполяционных командах,
    \item \textbf{MOV P1} -- движение в заданную точку P1,
    \item \textbf{WHILE, FOR} -- циклы с условиями,
    \item \textbf{OPEN "COM3:" AS \#1} -- открытие TCP/IP порта 10003 для подключения интерфейса \#1,
    \item \textbf{CLOSE \#1} -- закрытие TCP/IP порта 10003 для подключения интерфейса \#1,
    \item \textbf{DEF INTE DCOMM} -- объявление переменной DCOMM целочисленного типа.
\end{compactitem}


\subsection{Выбор подходящего языка программирования}
Существует достаточно много различных языков программирования,
подходящих под реализацию задачи взаимодействия с роботом с
компьютера. В рамках данной работы был выбран язык
программирования Python, так как он достаточно часто
используется в сфере робототехники, имеет достаточно простой
и легкочитаемый синтаксис,
имеет большое количество готовых библиотек и является кроссплатформенным
(программу можно запустить на разных операционных системах).


В ходе выполнения работы использовались следующие библиотеки:
\begin{compactitem}
    \item \textbf{socket} -- для работы с сетевыми соединениями,
    \item \textbf{typing} -- средства для статической типизации переменных и функций,
    \item \textbf{re} -- модуль для работы с регулярными выражениями,
    \item \textbf{yaml} -- для чтения и записи файлов в формате YAML,
    \item \textbf{enum} -- позволяет создавать перечисления с именованными значениями.
\end{compactitem}


Библиотека socket понадобилась для установки TCP-соединения между компьютером и роботом
и передачи/получения пакетов. Для общего улучшения и упрощения кода понадобилась
библиотека typing. Модуль re понадобился для обработки ответов с робота. Библиотека
yaml позволила реализовать чтение и сохранение введенных настроек IP и порта, чтобы
пользователю не пришлось каждый раз вводить эти данные заново при запуске программы.
Для перечисления команд, статусов сетевого взаимодействия с роботом,
декартовых и сочлененных координат понадобилась библиотека enum.


\section{Реализация программы для взаимодействия компьютера с роботом-манипулятором}
\subsection{Определение формата сообщения}
Для начала необходимо определиться
с форматом передаваемого с компьютера
на робот-манипулятор сообщения и обратно.


Сообщение должно быть простое, соответствующее
шаблону которое понимает робот.


Сначала будет отправляться номер команды, после чего
шесть координат и пара чисел для решения
обратной задачи кинематики, если хотим
передвижение по декартовым координатам.
Если движение сочлененное, то достаточно
передать шесть углов вращения.


Было решено, что робот будет отправлять компьютеру
12 координат и пару для решения обратной задачи кинематики
как одно сообщение.


В ходе выполнения работы экспериментальным путем было выяснено, что
робот отправляет свои декартовы и сочлененные координаты
в следующем формате:
$$
['(J_1,J_2,J_3,J_4,J_5,J_6)(X,Y,Z,A,B,C)(K_1,K_2)'],
$$
то есть как список, содержащий одну строку.


Это означает, что роботу нужно отправлять
координаты в виде строк шаблона:
\begin{compactitem}
    \item $(J_1,J_2,J_3,J_4,J_5,J_6)$ -- если движение сочлененное,
    \item $(X,Y,Z,A,B,C)(K_1,K_2)$ -- если движение в декартовых координатах,
\end{compactitem}
при этом все значения с плавающей точкой, кроме $K_i$ -- они целочисленные.


\subsection{Определение основных команд}
Проще всего отправлять роботу не строковые команды по типу 'EXIT',
а численные в виде строк. Например, команда '0' -- завершение работы
робота. Создадим для удобства перечисление enum, где каждой
команде с названием будет присвоено собственное число.
\begin{lstlisting}[label=robocmd, caption={Определение перечисления с командами для робота.}]
class RobotCommand(Enum):
    EXIT = 0
    GET_POSITION = 1
    MOVE_LINEAR = 2
    MOVE_JOINTS = 3
\end{lstlisting}


Краткое описание команд:
\begin{compactitem}
    \item \textbf{'0'} -- завершение работы робота. На клиентской стороне отключение связи,
    \item \textbf{'1'} -- робот вышлет 12 своих координат и кинематическую пару,
    \item \textbf{'2', '3'} -- движение робота по декартовым координатам или сочлененное соответственно.
    После робот снова высылает свою позицию.
\end{compactitem}


В программе для робота будем проверять пришедшее сообщение
на совпадение с одним из этих чисел. Далее будет
выполняться соответствующий алгоритм. Например, при получении
'2' робот будет двигаться по декартовым координатам в соответствии
с присланной после команды в заданном шаблоне следующей позицией робота, после чего
вышлет обратно 12 своих координат и пару чисел для решения
обратной задачи кинематики.


\subsection{Клиентская программа для общения с роботом}
Напишем клиентский скрипт, который будет основой сетевеого взаимодействия
компьютера с роботом.


Для начала определим статусы сетевого взаимодействия как перечисление.
Они помогут при отладке ошибок.
\begin{lstlisting}[label=lst:constat, caption={Определение перечисления статусов соединения компьютера с роботом.}]
class ConnectionStatus(Enum):
    SUCCESS = auto()
    NOT_CONNECTED = auto()
    CONNECTION_ERROR = auto()
    SEND_ERROR = auto()
    RECEIVE_ERROR = auto()
    NONE = auto()
\end{lstlisting}


Нумерация статусов автоматически с 1 и по порядку.
Смысл статусов полностью соответствует их названиям.


Теперь реализуем основные функции для взаимодействия компьютера с роботом.
Полностью скрипт представлен в приложении А на листинге \ref{lst:client}.


Краткое описание функций скрипта:
\begin{compactitem}
    \item \textbf{\_\_init\_\_(self)} -- при создании объекта класса вызывается
    данная функция. Она присвоит объекту поля: sock -- сетевой сокет с параметрами
    AF\_INET (семейство адресов IPv4), SOCK\_STREAM (протокол TCP);
    булевое connected -- значение истина или ложь в зависимости от
    того, подключен ли сокет к указанному IP и порту;
    \item \textbf{connect(self, ip: str, port: int) -> ConnectionStatus} --
    подключение сокета к указанному IP адресу и порту. Возвращает
    статус соединения. Также присваивает значение "истина"\,
    переменной connected, если подключение удалось;
    \item \textbf{disconnect(self) -> ConnectionStatus} -- закрывает
    соединение, если оно есть. Возвращает статус соединения.
    \item \textbf{send(self, data: str) -> ConnectionStatus} --
    кодирует переданную строку сообщение data и отправляет по
    протоколу TCP. Возвращает статус соединения;
    \item \textbf{receive(self, out\_data: list, buffer\_size: int = 1024) -> ConnectionStatus}
    -- принимает данные по протоколу TCP. Записывает в декодированном виде
    полученную информацию в список out\_data. Возвращает статус соединения.
\end{compactitem}


% \begin{figure}[H]
%     \centering
%     \includegraphics[scale=0.5]{cat.jpg}
%     \caption{Кошка}
%     \label{fig:fig_name}
% \end{figure}


% \begin{figure}[htbp]
%     \centering
%     \begin{subfigure}{0.3\textwidth}
%         \includegraphics[width=\linewidth]{cat2.jpg}
%         \caption{Картинка 1}
%     \end{subfigure}
%     \hfill
%     \begin{subfigure}{0.3\textwidth}
%         \includegraphics[width=\linewidth]{cat2.jpg}
%         \caption{Картинка 2}
%     \end{subfigure}
%     \hfill
%     \begin{subfigure}{0.3\textwidth}
%         \includegraphics[width=\linewidth]{cat2.jpg}
%         \caption{Картинка 3}
%     \end{subfigure}
%     \caption{Сравнение изображений}
%     \label{fig:fig_names}
% \end{figure}

\appendix
\renewcommand{\thesection}{\Asbuk{section}}

\section{Приложение}
\begin{lstlisting}[label=lst:client, caption={Основа для общения компьютера с роботом.}]
import socket
import connection_status as cs

class Client:
    def __init__(self):
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.connected = False

    def connect(self, ip: str, port: int) -> cs.ConnectionStatus:
        try:
            self.sock.connect((ip, port))
            self.connected = True

            return cs.ConnectionStatus.SUCCESS
        except socket.error:
            self.connected = False

            return cs.ConnectionStatus.CONNECTION_ERROR

    def disconnect(self) -> cs.ConnectionStatus:
        if self.connected:
            try:
                self.sock.close()
                self.connected = False

                return cs.ConnectionStatus.SUCCESS
            except socket.error:
                return cs.ConnectionStatus.CONNECTION_ERROR
        
        return cs.ConnectionStatus.NOT_CONNECTED

    def send(self, data: str) -> cs.ConnectionStatus:
        if not self.connected:
            return cs.ConnectionStatus.NOT_CONNECTED
        try:
            self.sock.sendall(data.encode('utf-8'))

            return cs.ConnectionStatus.SUCCESS
        except socket.error:
             return cs.ConnectionStatus.SEND_ERROR

    def receive(self, out_data: list, buffer_size: int = 1024) -> cs.ConnectionStatus:
        if not self.connected:
            return cs.ConnectionStatus.NOT_CONNECTED
        try:
            received = self.sock.recv(buffer_size)
            out_data.clear()
            out_data.append(received.decode('utf-8'))

            return cs.ConnectionStatus.SUCCESS
        except socket.error:
            return cs.ConnectionStatus.RECEIVE_ERROR
\end{lstlisting}

\end{document}